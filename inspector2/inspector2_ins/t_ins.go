// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/versus/inspector2/types

package types_ins

import (
	"encoding/json"
	"github.com/koykov/inspector"
	"github.com/koykov/versus/inspector2/types"
	"strconv"
)

func init() {
	inspector.RegisterInspector("T", TInspector{})
}

type TInspector struct {
	inspector.BaseInspector
}

func (i3 TInspector) TypeName() string {
	return "T"
}

func (i3 TInspector) Get(src any, path ...string) (any, error) {
	var buf any
	err := i3.GetTo(src, &buf, path...)
	return buf, err
}

func (i3 TInspector) GetTo(src any, buf *any, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *types.T
	_ = x
	if p, ok := src.(**types.T); ok {
		x = *p
	} else if p, ok := src.(*types.T); ok {
		x = p
	} else if v, ok := src.(types.T); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if path[0] == "L1" {
			x0 := x.L1
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "L2" {
					x1 := x0.L2
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "L3" {
							x2 := x1.L3
							_ = x2
							if len(path) > 3 {
								if x2 == nil {
									return
								}
								if path[3] == "S" {
									*buf = &x2.S
									return
								}
								if path[3] == "I" {
									*buf = &x2.I
									return
								}
								if path[3] == "F" {
									*buf = &x2.F
									return
								}
							}
							*buf = &x1.L3
							return
						}
					}
					*buf = &x0.L2
					return
				}
			}
			*buf = &x.L1
			return
		}
	}
	return
}

func (i3 TInspector) Compare(src any, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *types.T
	_ = x
	if p, ok := src.(**types.T); ok {
		x = *p
	} else if p, ok := src.(*types.T); ok {
		x = p
	} else if v, ok := src.(types.T); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "L1" {
			x0 := x.L1
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "L2" {
					x1 := x0.L2
					_ = x1
					if right == inspector.Nil {
						if cond == inspector.OpEq {
							*result = x1 == nil
						} else {
							*result = x1 != nil
						}
						return
					}
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "L3" {
							x2 := x1.L3
							_ = x2
							if right == inspector.Nil {
								if cond == inspector.OpEq {
									*result = x2 == nil
								} else {
									*result = x2 != nil
								}
								return
							}
							if len(path) > 3 {
								if x2 == nil {
									return
								}
								if path[3] == "S" {
									var rightExact string
									rightExact = right

									switch cond {
									case inspector.OpEq:
										*result = x2.S == rightExact
									case inspector.OpNq:
										*result = x2.S != rightExact
									case inspector.OpGt:
										*result = x2.S > rightExact
									case inspector.OpGtq:
										*result = x2.S >= rightExact
									case inspector.OpLt:
										*result = x2.S < rightExact
									case inspector.OpLtq:
										*result = x2.S <= rightExact
									}
									return
								}
								if path[3] == "I" {
									var rightExact int64
									t10, err10 := strconv.ParseInt(right, 0, 0)
									if err10 != nil {
										return err10
									}
									rightExact = int64(t10)
									switch cond {
									case inspector.OpEq:
										*result = x2.I == rightExact
									case inspector.OpNq:
										*result = x2.I != rightExact
									case inspector.OpGt:
										*result = x2.I > rightExact
									case inspector.OpGtq:
										*result = x2.I >= rightExact
									case inspector.OpLt:
										*result = x2.I < rightExact
									case inspector.OpLtq:
										*result = x2.I <= rightExact
									}
									return
								}
								if path[3] == "F" {
									var rightExact float64
									t11, err11 := strconv.ParseFloat(right, 0)
									if err11 != nil {
										return err11
									}
									rightExact = float64(t11)
									switch cond {
									case inspector.OpEq:
										*result = x2.F == rightExact
									case inspector.OpNq:
										*result = x2.F != rightExact
									case inspector.OpGt:
										*result = x2.F > rightExact
									case inspector.OpGtq:
										*result = x2.F >= rightExact
									case inspector.OpLt:
										*result = x2.F < rightExact
									case inspector.OpLtq:
										*result = x2.F <= rightExact
									}
									return
								}
							}
						}
					}
				}
			}
		}
	}
	return
}

func (i3 TInspector) Loop(src any, l inspector.Iterator, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *types.T
	_ = x
	if p, ok := src.(**types.T); ok {
		x = *p
	} else if p, ok := src.(*types.T); ok {
		x = p
	} else if v, ok := src.(types.T); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "L1" {
			x0 := x.L1
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "L2" {
					x1 := x0.L2
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return
						}
						if path[2] == "L3" {
							x2 := x1.L3
							_ = x2
							if len(path) > 3 {
								if x2 == nil {
									return
								}
							}
						}
					}
				}
			}
		}
	}
	return
}

func (i3 TInspector) SetWithBuffer(dst, value any, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *types.T
	_ = x
	if p, ok := dst.(**types.T); ok {
		x = *p
	} else if p, ok := dst.(*types.T); ok {
		x = p
	} else if v, ok := dst.(types.T); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		if path[0] == "L1" {
			x0 := x.L1
			if uvalue, ok := value.(*types.L1); ok {
				x0 = uvalue
			}
			if x0 == nil {
				x0 = &types.L1{}
				x.L1 = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				if path[1] == "L2" {
					x1 := x0.L2
					if uvalue, ok := value.(*types.L2); ok {
						x1 = uvalue
					}
					if x1 == nil {
						x1 = &types.L2{}
						x0.L2 = x1
					}
					_ = x1
					if len(path) > 2 {
						if x1 == nil {
							return nil
						}
						if path[2] == "L3" {
							x2 := x1.L3
							if uvalue, ok := value.(*types.L3); ok {
								x2 = uvalue
							}
							if x2 == nil {
								x2 = &types.L3{}
								x1.L3 = x2
							}
							_ = x2
							if len(path) > 3 {
								if x2 == nil {
									return nil
								}
								if path[3] == "S" {
									inspector.AssignBuf(&x2.S, value, buf)
									return nil
								}
								if path[3] == "I" {
									inspector.AssignBuf(&x2.I, value, buf)
									return nil
								}
								if path[3] == "F" {
									inspector.AssignBuf(&x2.F, value, buf)
									return nil
								}
							}
							x1.L3 = x2
						}
					}
					x0.L2 = x1
				}
			}
			x.L1 = x0
		}
	}
	return nil
}

func (i3 TInspector) Set(dst, value any, path ...string) error {
	return i3.SetWithBuffer(dst, value, nil, path...)
}

func (i3 TInspector) DeepEqual(l, r any) bool {
	return i3.DeepEqualWithOptions(l, r, nil)
}

func (i3 TInspector) DeepEqualWithOptions(l, r any, opts *inspector.DEQOptions) bool {
	var (
		lx, rx   *types.T
		leq, req bool
	)
	_, _, _, _ = lx, rx, leq, req
	if lp, ok := l.(**types.T); ok {
		lx, leq = *lp, true
	} else if lp, ok := l.(*types.T); ok {
		lx, leq = lp, true
	} else if lp, ok := l.(types.T); ok {
		lx, leq = &lp, true
	}
	if rp, ok := r.(**types.T); ok {
		rx, req = *rp, true
	} else if rp, ok := r.(*types.T); ok {
		rx, req = rp, true
	} else if rp, ok := r.(types.T); ok {
		rx, req = &rp, true
	}
	if !leq || !req {
		return false
	}
	if lx == nil && rx == nil {
		return true
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}

	lx1 := lx.L1
	rx1 := rx.L1
	_, _ = lx1, rx1
	if (lx1 == nil && rx1 != nil) || (lx1 != nil && rx1 == nil) {
		return false
	}
	if lx1 != nil && rx1 != nil {
		if inspector.DEQMustCheck("L1", opts) {
			lx2 := lx1.L2
			rx2 := rx1.L2
			_, _ = lx2, rx2
			if (lx2 == nil && rx2 != nil) || (lx2 != nil && rx2 == nil) {
				return false
			}
			if lx2 != nil && rx2 != nil {
				if inspector.DEQMustCheck("L1.L2", opts) {
					lx3 := lx2.L3
					rx3 := rx2.L3
					_, _ = lx3, rx3
					if (lx3 == nil && rx3 != nil) || (lx3 != nil && rx3 == nil) {
						return false
					}
					if lx3 != nil && rx3 != nil {
						if inspector.DEQMustCheck("L1.L2.L3", opts) {
							if lx3.S != rx3.S && inspector.DEQMustCheck("L1.L2.L3.S", opts) {
								return false
							}
							if lx3.I != rx3.I && inspector.DEQMustCheck("L1.L2.L3.I", opts) {
								return false
							}
							if !inspector.EqualFloat64(lx3.F, rx3.F, opts) && inspector.DEQMustCheck("L1.L2.L3.F", opts) {
								return false
							}
						}
					}
				}
			}
		}
	}
	return true
}

func (i3 TInspector) Unmarshal(p []byte, typ inspector.Encoding) (any, error) {
	var x types.T
	switch typ {
	case inspector.EncodingJSON:
		err := json.Unmarshal(p, &x)
		return &x, err
	default:
		return nil, inspector.ErrUnknownEncodingType
	}
}

func (i3 TInspector) Copy(x any) (any, error) {
	var r types.T
	switch x.(type) {
	case types.T:
		r = x.(types.T)
	case *types.T:
		r = *x.(*types.T)
	case **types.T:
		r = **x.(**types.T)
	default:
		return nil, inspector.ErrUnsupportedType
	}
	bc := i3.countBytes(&r)
	var l types.T
	err := i3.CopyTo(&r, &l, inspector.NewByteBuffer(bc))
	return &l, err
}

func (i3 TInspector) CopyTo(src, dst any, buf inspector.AccumulativeBuffer) error {
	var r types.T
	switch src.(type) {
	case types.T:
		r = src.(types.T)
	case *types.T:
		r = *src.(*types.T)
	case **types.T:
		r = **src.(**types.T)
	default:
		return inspector.ErrUnsupportedType
	}
	var l *types.T
	switch dst.(type) {
	case types.T:
		return inspector.ErrMustPointerType
	case *types.T:
		l = dst.(*types.T)
	case **types.T:
		l = *dst.(**types.T)
	default:
		return inspector.ErrUnsupportedType
	}
	bb := buf.AcquireBytes()
	var err error
	if bb, err = i3.cpy(bb, l, &r); err != nil {
		return err
	}
	buf.ReleaseBytes(bb)
	return nil
}

func (i3 TInspector) countBytes(x *types.T) (c int) {
	if x.L1 != nil {
		if x.L1.L2 != nil {
			if x.L1.L2.L3 != nil {
				c += len(x.L1.L2.L3.S)
			}
		}
	}
	return c
}

func (i3 TInspector) cpy(buf []byte, l, r *types.T) ([]byte, error) {
	if r.L1 != nil {
		if l.L1 == nil {
			l.L1 = &types.L1{}
		}
		if r.L1.L2 != nil {
			if l.L1.L2 == nil {
				l.L1.L2 = &types.L2{}
			}
			if r.L1.L2.L3 != nil {
				if l.L1.L2.L3 == nil {
					l.L1.L2.L3 = &types.L3{}
				}
				buf, l.L1.L2.L3.S = inspector.BufferizeString(buf, r.L1.L2.L3.S)
				l.L1.L2.L3.I = r.L1.L2.L3.I
				l.L1.L2.L3.F = r.L1.L2.L3.F
			}
		}
	}
	return buf, nil
}

func (i3 TInspector) Length(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *types.T
	_ = x
	if p, ok := src.(**types.T); ok {
		x = *p
	} else if p, ok := src.(*types.T); ok {
		x = p
	} else if v, ok := src.(types.T); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if path[0] == "L1" {
		if x.L1 != nil {
			if x.L1 == nil {
				return nil
			}
			if path[1] == "L2" {
				if x.L1.L2 != nil {
					if x.L1.L2 == nil {
						return nil
					}
					if path[2] == "L3" {
						if x.L1.L2.L3 != nil {
							if x.L1.L2.L3 == nil {
								return nil
							}
							if path[3] == "S" {
								*result = len(x.L1.L2.L3.S)
								return nil
							}
						}
					}
				}
			}
		}
	}
	return nil
}

func (i3 TInspector) Capacity(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *types.T
	_ = x
	if p, ok := src.(**types.T); ok {
		x = *p
	} else if p, ok := src.(*types.T); ok {
		x = p
	} else if v, ok := src.(types.T); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if path[0] == "L1" {
		if x.L1 != nil {
			if x.L1 == nil {
				return nil
			}
			if path[1] == "L2" {
				if x.L1.L2 != nil {
					if x.L1.L2 == nil {
						return nil
					}
					if path[2] == "L3" {
						if x.L1.L2.L3 != nil {
							if x.L1.L2.L3 == nil {
								return nil
							}
							if path[3] == "S" {
							}
						}
					}
				}
			}
		}
	}
	return nil
}

func (i3 TInspector) Reset(x any) error {
	var origin *types.T
	_ = origin
	switch x.(type) {
	case types.T:
		return inspector.ErrMustPointerType
	case *types.T:
		origin = x.(*types.T)
	case **types.T:
		origin = *x.(**types.T)
	default:
		return inspector.ErrUnsupportedType
	}
	if origin.L1 != nil {
		if origin.L1.L2 != nil {
			if origin.L1.L2.L3 != nil {
				origin.L1.L2.L3.S = ""
				origin.L1.L2.L3.I = 0
				origin.L1.L2.L3.F = 0
			}
		}
	}
	return nil
}
