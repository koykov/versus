// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/versus/inspector2/types

package types_ins

import (
	"encoding/json"
	"github.com/koykov/inspector"
	"github.com/koykov/versus/inspector2/types"
	"strconv"
)

func init() {
	inspector.RegisterInspector("L3", L3Inspector{})
}

type L3Inspector struct {
	inspector.BaseInspector
}

func (i2 L3Inspector) TypeName() string {
	return "L3"
}

func (i2 L3Inspector) Get(src any, path ...string) (any, error) {
	var buf any
	err := i2.GetTo(src, &buf, path...)
	return buf, err
}

func (i2 L3Inspector) GetTo(src any, buf *any, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *types.L3
	_ = x
	if p, ok := src.(**types.L3); ok {
		x = *p
	} else if p, ok := src.(*types.L3); ok {
		x = p
	} else if v, ok := src.(types.L3); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if path[0] == "S" {
			*buf = &x.S
			return
		}
		if path[0] == "I" {
			*buf = &x.I
			return
		}
		if path[0] == "F" {
			*buf = &x.F
			return
		}
	}
	return
}

func (i2 L3Inspector) Compare(src any, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *types.L3
	_ = x
	if p, ok := src.(**types.L3); ok {
		x = *p
	} else if p, ok := src.(*types.L3); ok {
		x = p
	} else if v, ok := src.(types.L3); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "S" {
			var rightExact string
			rightExact = right

			switch cond {
			case inspector.OpEq:
				*result = x.S == rightExact
			case inspector.OpNq:
				*result = x.S != rightExact
			case inspector.OpGt:
				*result = x.S > rightExact
			case inspector.OpGtq:
				*result = x.S >= rightExact
			case inspector.OpLt:
				*result = x.S < rightExact
			case inspector.OpLtq:
				*result = x.S <= rightExact
			}
			return
		}
		if path[0] == "I" {
			var rightExact int64
			t7, err7 := strconv.ParseInt(right, 0, 0)
			if err7 != nil {
				return err7
			}
			rightExact = int64(t7)
			switch cond {
			case inspector.OpEq:
				*result = x.I == rightExact
			case inspector.OpNq:
				*result = x.I != rightExact
			case inspector.OpGt:
				*result = x.I > rightExact
			case inspector.OpGtq:
				*result = x.I >= rightExact
			case inspector.OpLt:
				*result = x.I < rightExact
			case inspector.OpLtq:
				*result = x.I <= rightExact
			}
			return
		}
		if path[0] == "F" {
			var rightExact float64
			t8, err8 := strconv.ParseFloat(right, 0)
			if err8 != nil {
				return err8
			}
			rightExact = float64(t8)
			switch cond {
			case inspector.OpEq:
				*result = x.F == rightExact
			case inspector.OpNq:
				*result = x.F != rightExact
			case inspector.OpGt:
				*result = x.F > rightExact
			case inspector.OpGtq:
				*result = x.F >= rightExact
			case inspector.OpLt:
				*result = x.F < rightExact
			case inspector.OpLtq:
				*result = x.F <= rightExact
			}
			return
		}
	}
	return
}

func (i2 L3Inspector) Loop(src any, l inspector.Iterator, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *types.L3
	_ = x
	if p, ok := src.(**types.L3); ok {
		x = *p
	} else if p, ok := src.(*types.L3); ok {
		x = p
	} else if v, ok := src.(types.L3); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
	}
	return
}

func (i2 L3Inspector) SetWithBuffer(dst, value any, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *types.L3
	_ = x
	if p, ok := dst.(**types.L3); ok {
		x = *p
	} else if p, ok := dst.(*types.L3); ok {
		x = p
	} else if v, ok := dst.(types.L3); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		if path[0] == "S" {
			inspector.AssignBuf(&x.S, value, buf)
			return nil
		}
		if path[0] == "I" {
			inspector.AssignBuf(&x.I, value, buf)
			return nil
		}
		if path[0] == "F" {
			inspector.AssignBuf(&x.F, value, buf)
			return nil
		}
	}
	return nil
}

func (i2 L3Inspector) Set(dst, value any, path ...string) error {
	return i2.SetWithBuffer(dst, value, nil, path...)
}

func (i2 L3Inspector) DeepEqual(l, r any) bool {
	return i2.DeepEqualWithOptions(l, r, nil)
}

func (i2 L3Inspector) DeepEqualWithOptions(l, r any, opts *inspector.DEQOptions) bool {
	var (
		lx, rx   *types.L3
		leq, req bool
	)
	_, _, _, _ = lx, rx, leq, req
	if lp, ok := l.(**types.L3); ok {
		lx, leq = *lp, true
	} else if lp, ok := l.(*types.L3); ok {
		lx, leq = lp, true
	} else if lp, ok := l.(types.L3); ok {
		lx, leq = &lp, true
	}
	if rp, ok := r.(**types.L3); ok {
		rx, req = *rp, true
	} else if rp, ok := r.(*types.L3); ok {
		rx, req = rp, true
	} else if rp, ok := r.(types.L3); ok {
		rx, req = &rp, true
	}
	if !leq || !req {
		return false
	}
	if lx == nil && rx == nil {
		return true
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}

	if lx.S != rx.S && inspector.DEQMustCheck("S", opts) {
		return false
	}
	if lx.I != rx.I && inspector.DEQMustCheck("I", opts) {
		return false
	}
	if !inspector.EqualFloat64(lx.F, rx.F, opts) && inspector.DEQMustCheck("F", opts) {
		return false
	}
	return true
}

func (i2 L3Inspector) Unmarshal(p []byte, typ inspector.Encoding) (any, error) {
	var x types.L3
	switch typ {
	case inspector.EncodingJSON:
		err := json.Unmarshal(p, &x)
		return &x, err
	default:
		return nil, inspector.ErrUnknownEncodingType
	}
}

func (i2 L3Inspector) Copy(x any) (any, error) {
	var r types.L3
	switch x.(type) {
	case types.L3:
		r = x.(types.L3)
	case *types.L3:
		r = *x.(*types.L3)
	case **types.L3:
		r = **x.(**types.L3)
	default:
		return nil, inspector.ErrUnsupportedType
	}
	bc := i2.countBytes(&r)
	var l types.L3
	err := i2.CopyTo(&r, &l, inspector.NewByteBuffer(bc))
	return &l, err
}

func (i2 L3Inspector) CopyTo(src, dst any, buf inspector.AccumulativeBuffer) error {
	var r types.L3
	switch src.(type) {
	case types.L3:
		r = src.(types.L3)
	case *types.L3:
		r = *src.(*types.L3)
	case **types.L3:
		r = **src.(**types.L3)
	default:
		return inspector.ErrUnsupportedType
	}
	var l *types.L3
	switch dst.(type) {
	case types.L3:
		return inspector.ErrMustPointerType
	case *types.L3:
		l = dst.(*types.L3)
	case **types.L3:
		l = *dst.(**types.L3)
	default:
		return inspector.ErrUnsupportedType
	}
	bb := buf.AcquireBytes()
	var err error
	if bb, err = i2.cpy(bb, l, &r); err != nil {
		return err
	}
	buf.ReleaseBytes(bb)
	return nil
}

func (i2 L3Inspector) countBytes(x *types.L3) (c int) {
	c += len(x.S)
	return c
}

func (i2 L3Inspector) cpy(buf []byte, l, r *types.L3) ([]byte, error) {
	buf, l.S = inspector.BufferizeString(buf, r.S)
	l.I = r.I
	l.F = r.F
	return buf, nil
}

func (i2 L3Inspector) Length(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *types.L3
	_ = x
	if p, ok := src.(**types.L3); ok {
		x = *p
	} else if p, ok := src.(*types.L3); ok {
		x = p
	} else if v, ok := src.(types.L3); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if path[0] == "S" {
		*result = len(x.S)
		return nil
	}
	return nil
}

func (i2 L3Inspector) Capacity(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *types.L3
	_ = x
	if p, ok := src.(**types.L3); ok {
		x = *p
	} else if p, ok := src.(*types.L3); ok {
		x = p
	} else if v, ok := src.(types.L3); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if path[0] == "S" {
	}
	return nil
}

func (i2 L3Inspector) Reset(x any) error {
	var origin *types.L3
	_ = origin
	switch x.(type) {
	case types.L3:
		return inspector.ErrMustPointerType
	case *types.L3:
		origin = x.(*types.L3)
	case **types.L3:
		origin = *x.(**types.L3)
	default:
		return inspector.ErrUnsupportedType
	}
	origin.S = ""
	origin.I = 0
	origin.F = 0
	return nil
}
