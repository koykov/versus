// Code generated by inspc. DO NOT EDIT.
// source: github.com/koykov/versus/inspector2/types

package types_ins

import (
	"encoding/json"
	"github.com/koykov/inspector"
	"github.com/koykov/versus/inspector2/types"
	"strconv"
)

func init() {
	inspector.RegisterInspector("L2", L2Inspector{})
}

type L2Inspector struct {
	inspector.BaseInspector
}

func (i1 L2Inspector) TypeName() string {
	return "L2"
}

func (i1 L2Inspector) Get(src any, path ...string) (any, error) {
	var buf any
	err := i1.GetTo(src, &buf, path...)
	return buf, err
}

func (i1 L2Inspector) GetTo(src any, buf *any, path ...string) (err error) {
	if src == nil {
		return
	}
	var x *types.L2
	_ = x
	if p, ok := src.(**types.L2); ok {
		x = *p
	} else if p, ok := src.(*types.L2); ok {
		x = p
	} else if v, ok := src.(types.L2); ok {
		x = &v
	} else {
		return
	}
	if len(path) == 0 {
		*buf = &(*x)
		return
	}

	if len(path) > 0 {
		if path[0] == "L3" {
			x0 := x.L3
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "S" {
					*buf = &x0.S
					return
				}
				if path[1] == "I" {
					*buf = &x0.I
					return
				}
				if path[1] == "F" {
					*buf = &x0.F
					return
				}
			}
			*buf = &x.L3
			return
		}
	}
	return
}

func (i1 L2Inspector) Compare(src any, cond inspector.Op, right string, result *bool, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *types.L2
	_ = x
	if p, ok := src.(**types.L2); ok {
		x = *p
	} else if p, ok := src.(*types.L2); ok {
		x = p
	} else if v, ok := src.(types.L2); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "L3" {
			x0 := x.L3
			_ = x0
			if right == inspector.Nil {
				if cond == inspector.OpEq {
					*result = x0 == nil
				} else {
					*result = x0 != nil
				}
				return
			}
			if len(path) > 1 {
				if x0 == nil {
					return
				}
				if path[1] == "S" {
					var rightExact string
					rightExact = right

					switch cond {
					case inspector.OpEq:
						*result = x0.S == rightExact
					case inspector.OpNq:
						*result = x0.S != rightExact
					case inspector.OpGt:
						*result = x0.S > rightExact
					case inspector.OpGtq:
						*result = x0.S >= rightExact
					case inspector.OpLt:
						*result = x0.S < rightExact
					case inspector.OpLtq:
						*result = x0.S <= rightExact
					}
					return
				}
				if path[1] == "I" {
					var rightExact int64
					t4, err4 := strconv.ParseInt(right, 0, 0)
					if err4 != nil {
						return err4
					}
					rightExact = int64(t4)
					switch cond {
					case inspector.OpEq:
						*result = x0.I == rightExact
					case inspector.OpNq:
						*result = x0.I != rightExact
					case inspector.OpGt:
						*result = x0.I > rightExact
					case inspector.OpGtq:
						*result = x0.I >= rightExact
					case inspector.OpLt:
						*result = x0.I < rightExact
					case inspector.OpLtq:
						*result = x0.I <= rightExact
					}
					return
				}
				if path[1] == "F" {
					var rightExact float64
					t5, err5 := strconv.ParseFloat(right, 0)
					if err5 != nil {
						return err5
					}
					rightExact = float64(t5)
					switch cond {
					case inspector.OpEq:
						*result = x0.F == rightExact
					case inspector.OpNq:
						*result = x0.F != rightExact
					case inspector.OpGt:
						*result = x0.F > rightExact
					case inspector.OpGtq:
						*result = x0.F >= rightExact
					case inspector.OpLt:
						*result = x0.F < rightExact
					case inspector.OpLtq:
						*result = x0.F <= rightExact
					}
					return
				}
			}
		}
	}
	return
}

func (i1 L2Inspector) Loop(src any, l inspector.Iterator, buf *[]byte, path ...string) (err error) {
	if len(path) == 0 {
		return
	}
	if src == nil {
		return
	}
	var x *types.L2
	_ = x
	if p, ok := src.(**types.L2); ok {
		x = *p
	} else if p, ok := src.(*types.L2); ok {
		x = p
	} else if v, ok := src.(types.L2); ok {
		x = &v
	} else {
		return
	}

	if len(path) > 0 {
		if path[0] == "L3" {
			x0 := x.L3
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return
				}
			}
		}
	}
	return
}

func (i1 L2Inspector) SetWithBuffer(dst, value any, buf inspector.AccumulativeBuffer, path ...string) error {
	if len(path) == 0 {
		return nil
	}
	if dst == nil {
		return nil
	}
	var x *types.L2
	_ = x
	if p, ok := dst.(**types.L2); ok {
		x = *p
	} else if p, ok := dst.(*types.L2); ok {
		x = p
	} else if v, ok := dst.(types.L2); ok {
		x = &v
	} else {
		return nil
	}

	if len(path) > 0 {
		if path[0] == "L3" {
			x0 := x.L3
			if uvalue, ok := value.(*types.L3); ok {
				x0 = uvalue
			}
			if x0 == nil {
				x0 = &types.L3{}
				x.L3 = x0
			}
			_ = x0
			if len(path) > 1 {
				if x0 == nil {
					return nil
				}
				if path[1] == "S" {
					inspector.AssignBuf(&x0.S, value, buf)
					return nil
				}
				if path[1] == "I" {
					inspector.AssignBuf(&x0.I, value, buf)
					return nil
				}
				if path[1] == "F" {
					inspector.AssignBuf(&x0.F, value, buf)
					return nil
				}
			}
			x.L3 = x0
		}
	}
	return nil
}

func (i1 L2Inspector) Set(dst, value any, path ...string) error {
	return i1.SetWithBuffer(dst, value, nil, path...)
}

func (i1 L2Inspector) DeepEqual(l, r any) bool {
	return i1.DeepEqualWithOptions(l, r, nil)
}

func (i1 L2Inspector) DeepEqualWithOptions(l, r any, opts *inspector.DEQOptions) bool {
	var (
		lx, rx   *types.L2
		leq, req bool
	)
	_, _, _, _ = lx, rx, leq, req
	if lp, ok := l.(**types.L2); ok {
		lx, leq = *lp, true
	} else if lp, ok := l.(*types.L2); ok {
		lx, leq = lp, true
	} else if lp, ok := l.(types.L2); ok {
		lx, leq = &lp, true
	}
	if rp, ok := r.(**types.L2); ok {
		rx, req = *rp, true
	} else if rp, ok := r.(*types.L2); ok {
		rx, req = rp, true
	} else if rp, ok := r.(types.L2); ok {
		rx, req = &rp, true
	}
	if !leq || !req {
		return false
	}
	if lx == nil && rx == nil {
		return true
	}
	if (lx == nil && rx != nil) || (lx != nil && rx == nil) {
		return false
	}

	lx1 := lx.L3
	rx1 := rx.L3
	_, _ = lx1, rx1
	if (lx1 == nil && rx1 != nil) || (lx1 != nil && rx1 == nil) {
		return false
	}
	if lx1 != nil && rx1 != nil {
		if inspector.DEQMustCheck("L3", opts) {
			if lx1.S != rx1.S && inspector.DEQMustCheck("L3.S", opts) {
				return false
			}
			if lx1.I != rx1.I && inspector.DEQMustCheck("L3.I", opts) {
				return false
			}
			if !inspector.EqualFloat64(lx1.F, rx1.F, opts) && inspector.DEQMustCheck("L3.F", opts) {
				return false
			}
		}
	}
	return true
}

func (i1 L2Inspector) Unmarshal(p []byte, typ inspector.Encoding) (any, error) {
	var x types.L2
	switch typ {
	case inspector.EncodingJSON:
		err := json.Unmarshal(p, &x)
		return &x, err
	default:
		return nil, inspector.ErrUnknownEncodingType
	}
}

func (i1 L2Inspector) Copy(x any) (any, error) {
	var r types.L2
	switch x.(type) {
	case types.L2:
		r = x.(types.L2)
	case *types.L2:
		r = *x.(*types.L2)
	case **types.L2:
		r = **x.(**types.L2)
	default:
		return nil, inspector.ErrUnsupportedType
	}
	bc := i1.countBytes(&r)
	var l types.L2
	err := i1.CopyTo(&r, &l, inspector.NewByteBuffer(bc))
	return &l, err
}

func (i1 L2Inspector) CopyTo(src, dst any, buf inspector.AccumulativeBuffer) error {
	var r types.L2
	switch src.(type) {
	case types.L2:
		r = src.(types.L2)
	case *types.L2:
		r = *src.(*types.L2)
	case **types.L2:
		r = **src.(**types.L2)
	default:
		return inspector.ErrUnsupportedType
	}
	var l *types.L2
	switch dst.(type) {
	case types.L2:
		return inspector.ErrMustPointerType
	case *types.L2:
		l = dst.(*types.L2)
	case **types.L2:
		l = *dst.(**types.L2)
	default:
		return inspector.ErrUnsupportedType
	}
	bb := buf.AcquireBytes()
	var err error
	if bb, err = i1.cpy(bb, l, &r); err != nil {
		return err
	}
	buf.ReleaseBytes(bb)
	return nil
}

func (i1 L2Inspector) countBytes(x *types.L2) (c int) {
	if x.L3 != nil {
		c += len(x.L3.S)
	}
	return c
}

func (i1 L2Inspector) cpy(buf []byte, l, r *types.L2) ([]byte, error) {
	if r.L3 != nil {
		if l.L3 == nil {
			l.L3 = &types.L3{}
		}
		buf, l.L3.S = inspector.BufferizeString(buf, r.L3.S)
		l.L3.I = r.L3.I
		l.L3.F = r.L3.F
	}
	return buf, nil
}

func (i1 L2Inspector) Length(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *types.L2
	_ = x
	if p, ok := src.(**types.L2); ok {
		x = *p
	} else if p, ok := src.(*types.L2); ok {
		x = p
	} else if v, ok := src.(types.L2); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if path[0] == "L3" {
		if x.L3 != nil {
			if x.L3 == nil {
				return nil
			}
			if path[1] == "S" {
				*result = len(x.L3.S)
				return nil
			}
		}
	}
	return nil
}

func (i1 L2Inspector) Capacity(src any, result *int, path ...string) error {
	if src == nil {
		return nil
	}
	var x *types.L2
	_ = x
	if p, ok := src.(**types.L2); ok {
		x = *p
	} else if p, ok := src.(*types.L2); ok {
		x = p
	} else if v, ok := src.(types.L2); ok {
		x = &v
	} else {
		return inspector.ErrUnsupportedType
	}

	*result = 0
	if len(path) == 0 {
		return nil
	}
	if path[0] == "L3" {
		if x.L3 != nil {
			if x.L3 == nil {
				return nil
			}
			if path[1] == "S" {
			}
		}
	}
	return nil
}

func (i1 L2Inspector) Reset(x any) error {
	var origin *types.L2
	_ = origin
	switch x.(type) {
	case types.L2:
		return inspector.ErrMustPointerType
	case *types.L2:
		origin = x.(*types.L2)
	case **types.L2:
		origin = *x.(**types.L2)
	default:
		return inspector.ErrUnsupportedType
	}
	if origin.L3 != nil {
		origin.L3.S = ""
		origin.L3.I = 0
		origin.L3.F = 0
	}
	return nil
}
